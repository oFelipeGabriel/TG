<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/addons/p5.dom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/addons/p5.sound.min.js"></script> -->
    <script src="libs/p5.min.js"></script>
    <script src="libs/tf.min.js"></script>
    <script type="text/javascript" src="libs/tf.min.js"></script>
  </head>
  <body>
    <script src="nn.js"></script>
    <script src="funcs.js"></script>
    <script src="raio.js"></script>
    <script src="particula.js"></script>
    <script src="limite.js"></script>
    <script type="text/javascript">
    const TOTAL = 50;
    const MUTATION_RATE = 0.1;
    const LIFESPAN = 25;
    const SIGHT = 50;
    function pldistance(p1, p2, x, y) {
      const num = abs((p2.y - p1.y) * x - (p2.x - p1.x) * y + p2.x * p1.y - p2.y * p1.x);
      const den = p5.Vector.dist(p1, p2);
      return num / den;
    }
    class Carro{
      construct(x1,y1){
        this.x = x1;
        this.y = y1;
      }
      draw(img,x,y){
        image(img,x-20,y-20, 60,40);

      }
    }
    class Parede{
      constructor(x1, y1, x2, y2){
        this.a = createVector(x1,y1);
        this.b = createVector(x2,y2);
      }

      midpoint(){
        return createVector((this.a.x + this.b.x)* 0.5, (this.a.y + this.b.y) * 0.5);
      }

      show(){
        strokeWeight(4);
        stroke(217, 196, 41);
        line(this.a.x, this.a.y, this.b.x, this.b.y);
      }
    }

    class Particula{
      constructor(brain){
        this.fitness = 0;
        this.dead = false;
        this.finished = false;
        this.pos = createVector(start.x, start.y);
        this.vel = createVector();
        this.acc = createVector();
        this.maxspeed = 5;
        this.maxforce = 0.2;
        this.sight = SIGHT;
        this.rays = [];
        this.index = 0;
        this.counter = 0;
        if(brain){
          this.brain = brain.copy();
        }else{
          this.brain = new RedeNaural(this.rays.length,this.rays.length*2, 2)
        }
      }
      dispose(){

      }
      applyForce(force){
        this.acc.add(force);
      }
      update(){
        if(!this.dead & !this.finished){
          this.pos.add(this.vel);
          this.vel.add(this.acc);
          this.vel.limit(this.maxspeed);
          this.acc.set(0,0);
          this.counter++;
          if(this.counter > LIFESPAN){
            this.dead = true;
          }
        }
      }
      check(checkpoints){
        if(!this.finished){
          this.goal = checkpoints[this.index];
          const d = pldistance(
            this.goal.a, this.goal.b,
            this.pos.x,  this.pos.y
          );
          if(d < 5 ){
            this.index = (this.index + 1) % checkpoints.length;
            this.fitness++;
            this.counter = 0;
          }
        }
      }
      calculateFitness(){
        this.fitness = pow(2, this.fitness);
      }
      look(walls){
        const inputs = [];
        for(let i=0; i<this.rays.length;i++){
          if(record<5){
            this.dead = true;
          }
          inputs[i] = map(record, 0, 50, 1, 0);
        }
        const output = this.brain.predict(inputs);
        let angle = map(output[0], 0, 1, -PI, PI);
        let speed = map(output[1], 0, 1, 0, this.maxspeed);
        angle += this.vel.heading();
        const steering = p5.Vector.fromAngle(angle);
        steering.setMag(speed);
        steering.sub(this.vel);
        steering.limit(this.maxforce);
        this.applyForce(steering);
      }
      bounds(){
        if(
          this.pos.x > width ||
          this.pos.x < 0 ||
          this.pos.y > height ||
          this.pos.y < 0
        ){
        this.dead = true;
        }
      }
      show(){
        push();
        translate(this.pos.x, this.pos.y);
        const heading = this.vel.heading();
        rotate(heading);
        fill(0, 100, 0);
        rectMode(CENTER);
        rect(0,0,10,5);
        pop();
      }
    }
    class RedeNaural{
      constructor(a, b, c, d){
        if(a instanceof tf.Sequential){
          this.model = a;
          this.input_nodes = b;
          this.hidden_nodes = c;
          this.output_nodes = d;
        }else{
          this.input_nodes = a;
          this.hidden_nodes = b;
          this.output_nodes = c;
          this.model = this.createModel();
        }
      }
      copy(){
        return tf.tody(() => {
          const modelCopy = this.createModel();
          const weights = this.model.getWeights();
          const weightCopies = [];
          for (let i=0; i<weights.length; i++){
            weightCopies[i] = weights[i].clone();
          }
          modelCopy.setWeights(weightCopies);
          return new RedeNaural(
              modelCopy,
              this.input_nodes,
              this.hidden_nodes,
            this.output_nodes);
        });
      }
      mutate(rate){
        td.tidy(() => {
          const weights = this.model.getWeights();
          const mutatedWeights = [];
          for(let i=0; i<weights.length; i++){
            let tensor = weights[i];
            let shape = weights[i].shape;
            let values = tensor.dataSync().slice();
            for(let j=0; j<values.length; j++){
              if(random(1)<rate){
                let w = values[j];
                values[j] = w + randomGaussian();
              }
            }
            let newTensor = tf.tensor(values, shape);
            mutatedWeights[i] = newTensor;
          }
          this.model.setWeights(mutatedWeights);
        });
      }
      dispose(){
        this.model.dispose();
      }
      predict(inputs){
        return tf.tidy(() => {
          const xs = tf.tensor2d([inputs]);
          const ys = this.model.predict(xs);
          const outputs = ys.dataSync();
          return outputs;
        })
      }
      createModel(){
        const model = tf.sequential();
        const hidden = tf.layers.dense({
          units: this.hidden_nodes,
          inputShape: [this.input_nodes],
          activation: 'sigmoid'
        });
        model.add(output);
        return model;
      }
    }
    let img; // Declare variable 'img'.
    let c;
    let paredes = [];
    let dentro = []
    let fora = [];
    let population = [];
    let speedSlider = 5;
    function buildTrack() {
      checkpoints = [];
      inside = [];
      outside = [];

      let noiseMax = 4;
      const total = 60;
      const pathWidth = 60;
      let startX = random(100);
      let startY = random(100);
      for (let i = 0; i < total; i++) {
        let a = map(i, 0, total, 0, TWO_PI);
        let xoff = map(cos(a), -1, 1, 0, noiseMax) + startX;
        let yoff = map(sin(a), -1, 1, 0, noiseMax) + startY;
        let xr = map(noise(xoff, yoff), 0, 2, 100, width * 0.5);
        let yr = map(noise(xoff, yoff), 0, 2, 100, height * 0.5);
        let x1 = width / 2 + (xr - pathWidth) * cos(a);
        let y1 = height / 2 + (yr - pathWidth) * sin(a);
        let x2 = width / 2 + (xr + pathWidth) * cos(a);
        let y2 = height / 2 + (yr + pathWidth) * sin(a);
        checkpoints.push(new Parede(x1, y1, x2, y2));
        paredes.push(new Parede(x1, y1, x2, y2));
        inside.push(createVector(x1, y1));
        outside.push(createVector(x2, y2));
       }
       dentro = inside;
       fora = outside;
      walls = [];
      for (let i = 0; i < checkpoints.length; i++) {
        let a1 = inside[i];
        let b1 = inside[(i + 1) % checkpoints.length];
        paredes.push(new Parede(a1.x, a1.y, b1.x, b1.y));
        let a2 = outside[i];
        let b2 = outside[(i + 1) % checkpoints.length];
        paredes.push(new Parede(a2.x, a2.y, b2.x, b2.y));
      }

      start = checkpoints[0].midpoint();
      end = checkpoints[checkpoints.length - 1].midpoint();
    }

    function setup() {
      createCanvas(1220, 600);
      tf.setBackend('cpu');
      buildTrack();
      c = new Carro(mouseX, mouseY);
      img = loadImage('assets/Red_racing_car_top_view.png'); // Load the image
      for (let i = 0; i < TOTAL; i++) {
        population[i] = new Particula();
      }
      //speedSlider = createSlider(1, 10, 1);
    }

    function draw() {
      const cycles = speedSlider;
      background(51, 51, 51);
      for(let x=0;x<paredes.length;x++){
        paredes[x].show();
      }
      let bestP = population[0];
      for(let n=0;n<cycles;n++){
        for(let particle in population){
          population[particle].look(walls);
          population[particle].check(checkpoints);
          population[particle].bounds();
          population[particle].update();
          population[particle].show();
        }
      }
    }
    </script>
  </body>
</html>
