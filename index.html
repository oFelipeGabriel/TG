<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/addons/p5.dom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/addons/p5.sound.min.js"></script> -->
    <script src="libs/p5.min.js"></script>
    <script src="libs/tf.min.js"></script>
    <script type="text/javascript" src="libs/tf.min.js"></script>
  </head>
  <body>
    <script src="nn.js"></script>
    <script src="funcs.js"></script>
    <script src="raio.js"></script>
    <script src="particula.js"></script>
    <script src="limite.js"></script>
    <script type="text/javascript">
    const TOTAL = 50;
    const MUTATION_RATE = 0.1;
    const LIFESPAN = 25;
    const SIGHT = 50;
    function pldistance(p1, p2, x, y) {
      const num = abs((p2.y - p1.y) * x - (p2.x - p1.x) * y + p2.x * p1.y - p2.y * p1.x);
      const den = p5.Vector.dist(p1, p2);
      return num / den;
    }
    class Carro{
      construct(x1,y1){
        this.x = x1;
        this.y = y1;
      }
      draw(img,x,y){
        image(img,x-20,y-20, 60,40);

      }
    }
    class Parede{
      constructor(x1, y1, x2, y2){
        this.a = createVector(x1,y1);
        this.b = createVector(x2,y2);
      }

      midpoint(){
        return createVector((this.a.x + this.b.x)* 0.5, (this.a.y + this.b.y) * 0.5);
      }

      show(){
        strokeWeight(4);
        stroke(217, 196, 41);
        line(this.a.x, this.a.y, this.b.x, this.b.y);
      }
    }
    class Raio{
      constructor(pos, angle){
        this.pos = pos;
        this.angle = angle;
        this.dir = p5.Vector.fromAngle(angle);
      }
      lookAt(x, y){
        this.dir.x = x - this.pos.x;
        this.dir.y = y- this.pos.y;
        this.dir.normalize();
      }
      rotate(offset){
        this.dir = p5.Vector.fromAngle(this.angle + offset);
      }
      show(){
        strokeWeight(2);
        stroke(255,255,255,40);
        push();
        translate(this.pos.x, this.pos.y);
        line(0, 0, this.dir.x * SIGHT, this.dir.y * SIGHT);
        pop();
      }
      cast(wall){
        const x1 = wall.a.x;
        const y1 = wall.a.y;
        const x2 = wall.b.x;
        const y2 = wall.b.y;

        const x3 = this.pos.x;
        const y3 = this.pos.y;
        const x4 = this.pos.x + this.dir.x;
        const y4 = this.pos.y + this.dir.y;

        const den = (x1 - x2)*(y3 - y4)-(y1 - y2)*(x3 - x4);
        if(den == 0){
          return;
        }
        const t = ((x1 - x3)*(y3 - y4)-(y1 - y3)*(x3 - x4)) / den;
        const u = -((x1 - x2)*(y1 - y3)-(y1 - y2)*(x1 - x3)) / den;
        if(t > 0 && t < 1 && u > 0){
          const pt = createVector();
          pt.x = x1 + t * (x2 - x1);
          pt.y = y1 + t * (y2 - y1);
          return pt;
        } else{
          return;
        }
      }
    }
    class Particula{
      constructor(brain){
        this.fitness = 0;
        this.dead = false;
        this.finished = false;
        this.pos = createVector(start.x, start.y);
        this.vel = createVector();
        this.acc = createVector();
        this.maxspeed = 5;
        this.maxforce = 0.2;
        this.sight = SIGHT;
        this.rays = [];
        this.index = 0;
        this.counter = 0;
        this.img = loadImage('assets/Red_racing_car_top_view.png'); // Load the image
        for(let a = -45; a < 45; a += 15){
          this.rays.push(new Ray(this.pos, radians(a)));
        }
        if(brain){
          this.brain = brain.copy();
        }else{
          this.brain = new RedeNaural(this.rays.length,this.rays.length*2, 2)
        }
      }
      dispose(){

      }
      applyForce(force){
        this.acc.add(force);
      }
      update(){
        if(!this.dead & !this.finished){
          this.pos.add(this.vel);
          this.vel.add(this.acc);
          this.vel.limit(this.maxspeed);
          this.acc.set(0,0);
          this.counter++;
          if(this.counter > LIFESPAN){
            this.dead = true;
          }

          for(let i = 0; i < this.rays.length; i++){
            this.rays[i].rotate(this.vel.heading());
          }
        }
      }
      check(checkpoints){
        if(!this.finished){
          this.goal = checkpoints[this.index];
          const d = pldistance(
            this.goal.a, this.goal.b,
            this.pos.x,  this.pos.y
          );
          if(d < 5 ){
            this.index = (this.index + 1) % checkpoints.length;
            this.fitness++;
            this.counter = 0;
          }
        }
      }
      calculateFitness(){
        this.fitness = pow(2, this.fitness);
      }
      look(walls){
        const inputs = [];
        for(let i=0; i<this.rays.length;i++){
          const ray = this.rays[i];
          let closest = null;
          let record = this.sight;
          for(let wall of walls){
            const pt = ray.cast(wall);
            if(pt){
              const d = p5.Vector.dist(this.pos, pt);
              if(d < record && d < this.sight){
                record = d;
                closest = pt;
              }
            }
          }
          if(record<5){
            this.dead = true;
          }
          inputs[i] = map(record, 0, 50, 1, 0);
        }
        const output = this.brain.predict(inputs);
        let angle = map(output[0], 0, 1, -PI, PI);
        let speed = map(output[1], 0, 1, 0, this.maxspeed);
        angle += this.vel.heading();
        const steering = p5.Vector.fromAngle(angle);
        steering.setMag(speed);
        steering.sub(this.vel);
        steering.limit(this.maxforce);
        this.applyForce(steering);
      }
      bounds(){
        if(
          this.pos.x > width ||
          this.pos.x < 0 ||
          this.pos.y > height ||
          this.pos.y < 0
        ){
        this.dead = true;
        }
      }
      show(){
        push();

        translate(this.pos.x, this.pos.y);

        const heading = this.vel.heading();
        rotate(heading);
        // fill(0, 100, 0);
        // rectMode(CENTER);
        // rect(0,0,10,5);
        pop();
      }
      image(){
        return image(this.img, this.pos.x, this.pos.y, 40, 40);;
      }
      highlight() {
        push();
        translate(this.pos.x, this.pos.y);
        const heading = this.vel.heading();
        rotate(heading);
        stroke(0, 255, 0);
        //fill(0, 255, 0);
        rectMode(CENTER);
        rect(0, 0, 20, 10, 50, 50);

        pop();
        for (let ray of this.rays) {
          ray.show();
        }
        if (this.goal) {
          this.goal.show();
        }
      }
    }
    class RedeNaural{
      constructor(a, b, c, d){
        if(a instanceof tf.Sequential){
          this.model = a;
          this.input_nodes = b;
          this.hidden_nodes = c;
          this.output_nodes = d;
        }else{
          this.input_nodes = a;
          this.hidden_nodes = b;
          this.output_nodes = c;
          this.model = this.createModel();
        }
      }
      copy(){
        return tf.tidy(() => {
          const modelCopy = this.createModel();
          const weights = this.model.getWeights();
          const weightCopies = [];
          for (let i=0; i<weights.length; i++){
            weightCopies[i] = weights[i].clone();
          }
          modelCopy.setWeights(weightCopies);
          return new RedeNaural(
              modelCopy,
              this.input_nodes,
              this.hidden_nodes,
            this.output_nodes);
        });
      }
      mutate(rate){
        tf.tidy(() => {
          const weights = this.model.getWeights();
          const mutatedWeights = [];
          for(let i=0; i<weights.length; i++){
            let tensor = weights[i];
            let shape = weights[i].shape;
            let values = tensor.dataSync().slice();
            for(let j=0; j<values.length; j++){
              if(random(1)<rate){
                let w = values[j];
                values[j] = w + randomGaussian();
              }
            }
            let newTensor = tf.tensor(values, shape);
            mutatedWeights[i] = newTensor;
          }
          this.model.setWeights(mutatedWeights);
        });
      }
      dispose(){
        this.model.dispose();
      }
      predict(inputs){
        return tf.tidy(() => {
          const xs = tf.tensor2d([inputs]);
          const ys = this.model.predict(xs);
          const outputs = ys.dataSync();
          return outputs;
        })
      }
      createModel(){
        const model = tf.sequential();
        const hidden = tf.layers.dense({
          units: this.hidden_nodes,
          inputShape: [this.input_nodes],
          activation: 'sigmoid'
        });
        model.add(hidden);
        const output = tf.layers.dense({
          units: this.output_nodes,
          activation: 'sigmoid'
        });
        model.add(output);
        return model;
      }
    }
    let img; // Declare variable 'img'.
    let c;
    let paredes = [];
    let dentro = []
    let fora = [];
    let population = [];
    let savedParticles = [];
    let speedSlider = 5;
    const maxFitness = 500;
    let changeMap = false;
    let generationCount = 0;
    function buildTrack() {
      checkpoints = [];
      inside = [];
      outside = [];

      let noiseMax = 4;
      const total = 60;
      const pathWidth = 60;
      let startX = random(100);
      let startY = random(100);
      for (let i = 0; i < total; i++) {
        let a = map(i, 0, total, 0, TWO_PI);
        let xoff = map(cos(a), -1, 1, 0, noiseMax) + startX;
        let yoff = map(sin(a), -1, 1, 0, noiseMax) + startY;
        let xr = map(noise(xoff, yoff), 0, 2, 100, width * 0.5);
        let yr = map(noise(xoff, yoff), 0, 2, 100, height * 0.5);
        let x1 = width / 2 + (xr - pathWidth) * cos(a);
        let y1 = height / 2 + (yr - pathWidth) * sin(a);
        let x2 = width / 2 + (xr + pathWidth) * cos(a);
        let y2 = height / 2 + (yr + pathWidth) * sin(a);
        checkpoints.push(new Parede(x1, y1, x2, y2));
        //walls.push(new Parede(x1, y1, x2, y2));
        inside.push(createVector(x1, y1));
        outside.push(createVector(x2, y2));
       }
       dentro = inside;
       fora = outside;
      walls = [];
      for (let i = 0; i < checkpoints.length; i++) {
        let a1 = inside[i];
        let b1 = inside[(i + 1) % checkpoints.length];
        walls.push(new Parede(a1.x, a1.y, b1.x, b1.y));
        let a2 = outside[i];
        let b2 = outside[(i + 1) % checkpoints.length];
        walls.push(new Parede(a2.x, a2.y, b2.x, b2.y));
      }

      start = checkpoints[0].midpoint();
      end = checkpoints[checkpoints.length - 1].midpoint();
    }

    function setup() {
      createCanvas(1220, 600);
      tf.setBackend('cpu');
      buildTrack();

      for (let i = 0; i < TOTAL; i++) {
        population[i] = new Particula();
      }
      //speedSlider = createSlider(1, 10, 1);
    }

    function draw() {
      const cycles = speedSlider;
      background(51, 51, 51);
      for(let x=0;x<paredes.length;x++){
        paredes[x].show();
      }
      let bestP = population[0];
      for(let n=0;n<cycles;n++){
        for(let particle in population){
          population[particle].look(walls);
          population[particle].check(checkpoints);
          population[particle].bounds();
          population[particle].update();
          population[particle].show();

          if( population[particle]>bestP.fitness){
            bestP = population[particle];
          }
        }
        for(let i = population.length -1; i >= 0; i--){
          const particle = population[i];
          if(particle.dead || particle.finished){
            savedParticles.push(population.splice(i, 1)[0]);
          }
          if(!changeMap && particle.fitness > maxFitness){
            changeMap = true;
          }
        }
        if(population.length !== 0 && changeMap){
          for (let i = population.length -1; i >= 0; i--){
            savedParticles.push(population.splice(i, 1)[0]);
          }
          buildTrack();
          nextGeneration();
          generationCount++;
          changeMap = false;
        }
        if(population.length == 0){
          buildTrack();
          nextGeneration();
          generationCount++;
        }
      }
      for (let wall of walls) {
        wall.show();
      }
      for (let particle of population) {
        particle.show();
      }

      bestP.highlight();

      //fill(255);
      textSize(24);
      noStroke();

      text('generation ' + generationCount, 10, 50);
    }
    </script>
  </body>
</html>
